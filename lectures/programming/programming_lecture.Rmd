---
title: "Programming"
author: 
date: 
urlcolor: blue
output: 
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true # toc_float option to float the table of contents to the left of the main document content. floating table of contents will always be visible even when the document is scrolled
      #collapsed: false # collapsed (defaults to TRUE) controls whether the TOC appears with only the top-level (e.g., H2) headers. If collapsed initially, the TOC is automatically expanded inline when necessary
      #smooth_scroll: true # smooth_scroll (defaults to TRUE) controls whether page scrolls are animated when TOC items are navigated to via mouse clicks
    number_sections: true
    fig_caption: true # ? this option doesn't seem to be working for figure inserted below outside of r code chunk    
    highlight: tango # Supported styles include "default", "tango", "pygments", "kate", "monochrome", "espresso", "zenburn", and "haddock" (specify null to prevent syntax    
    theme: default # theme specifies the Bootstrap theme to use for the page. Valid themes include default, cerulean, journal, flatly, readable, spacelab, united, cosmo, lumen, paper, sandstone, simplex, and yeti.
    df_print: tibble #options: default, tibble, paged
    keep_md: true # may be helpful for storing on github
    
---


# Introduction

Load packages:

```{r, message=FALSE}
library(tidyverse)
library(ggplot2)
```


The "programming" unit will introduce you to tools that tell the computer to do the same or similar things over and over, without writing code over and over. And the code you write to do things over and over, will be able to do things differently depending on conditions of the data or depending on things you specify. 

Paraphrasing Will Doyle

> "Computers love to do the same thing over and over. It's their favorite thing to do. Learn to make your computer happy."

The core foci of this unit are:

- iteration (loops)
- conditionals (if, if else)
- functions

But more than learning these things, this unit is about developing a more formal, rigorous understanding of programming concepts so that you can become a more powerful programmer. Towards that end, we will be reading chapters from Wickhams free text book [_Advanced R_](https://adv-r.hadley.nz/)

  
In fact, please spend 10 minutes reading the [Chapter 1](https://adv-r.hadley.nz/introduction.html) (sections 1.1 through 1.5)

# Foundational concepts

## Data structures and types

What is an **object**?

- Everything in R is an object
- We can classify objects based on their _class_ and _type_
- The _class_ of the object determines what kind of functions we can apply to it
  - E.g., "Date" functions usually only work on objects with a `Date` class
  - E.g., "String" functions usually only work with on objects with a `character` class
  - E.g., Functions that do mathematical computation usually work on objects with a `numeric` class
- Objects may be combined to form data structures

<br>
<details><summary>Class and object-oriented programming</summary>

> "Object-oriented programming (OOP) refers to a type of computer programming in which programmers define not only the data type of a data structure, but also the types of operations (functions) that can be applied to the data structure."

*Source: [Webopedia](https://www.webopedia.com/TERM/O/object_oriented_programming_OOP.html)*

<br>
R is an **object-oriented programming language**:

- The _class_ of an object is fundamental to object-oriented programming because:
  - It determines which functions can be applied to the object
  - It also determines what those functions do to the object
    - E.g., A specific function might do one thing to objects of __class__ A and another thing to objects of __class__ B
    - What a function does to objects of different class is determined by whoever wrote the function
- Many different object classes exist in R
- You can also create our own classes
    - E.g., The `labelled` class is an object class created by Hadley Wickham when he created the `haven` package
- In this course we will work with classes that have been created by others

</details>
<br>

[![](https://d33wubrfki0l68.cloudfront.net/1d1b4e1cf0dc5f6e80f621b0225354b0addb9578/6ee1c/diagrams/data-structures-overview.png){width=400px}](https://r4ds.had.co.nz/vectors.html)

*Credit: [R for Data Science](https://r4ds.had.co.nz/vectors.html)*

<br>
Basic **data structures**:

- [Atomic vectors](#atomtic-vectors)
- [Lists](#lists)
  - [Dataframes](#dataframes)
  
Basic **data types**:

- Logical (`TRUE`, `FALSE`)
- Numeric (e.g., `5`, `2.5`)
- Integer (e.g., `1L`, `4L`, where `L` tells R to store as `integer` type)
- Character (e.g., `"R is fun"`)

Functions for investigating R objects (From [Data Types and Structures](https://swcarpentry.github.io/r-novice-inflammation/13-supp-data-structures/))

- `str()`: Compactly display the internal structure of an R object
- `class()`: What kind of object is it (high-level)?
- `typeof()`: What is the object's data type (low-level)?

### Atomtic vectors

What are **atomic vectors**?

- **Atomic vectors** are objects that contains elements
- Elements must be of the same data type (i.e., _homogeneous_)
- Elements can be named to form a _named atomic vector_
- The `class()` and `typeof()` a vector describes the elements it contains

<br>
<details><summary>**Example**: Investigating logical vectors</summary>

```{r}
v <- c(TRUE, FALSE, FALSE, TRUE)
str(v)
class(v)
typeof(v)
```

</details>

<br>
<details><summary>**Example**: Investigating numeric vectors</summary>

```{r}
v <- c(1, 3, 5, 7)
str(v)
class(v)
typeof(v)
```
</details>

<br>
<details><summary>**Example**: Investigating integer vectors</summary>

```{r}
v <- c(1L, 3L, 5L, 7L)
str(v)
class(v)
typeof(v)
```

</details>

<br>
<details><summary>**Example**: Investigating character vectors</summary>

Each element in a `character` vector is a **string** (covered in next section):

```{r}
v <- c("a", "b", "c", "d")
str(v)
class(v)
typeof(v)
```

</details>

<br>
<details><summary>**Example**: Investigating named vectors</summary>

```{r}
v <- c(v1 = 1, v2 = 2, v3 = 3)
v
str(v)
class(v)
typeof(v)
```

</details>


### Lists

What are **lists**?

- **Lists** are objects that contains elements
- Elements do not need to be of the same type (i.e., _heterogeneous_)
  - Elements can be atomic vectors or even other lists
- Elements can be named to form a _named list_
- The `class()` and `typeof()` a list is `list`

<br>
<details><summary>**Example**: Investigating heterogeneous lists</summary>

```{r}
l <- list(2.5, "abc", TRUE, c(1L, 2L, 3L))
str(l)
class(l)
typeof(l)
```

</details>

<br>
<details><summary>**Example**: Investigating nested lists</summary>

```{r}
l <- list(list(TRUE, c(1, 2, 3), list(c("a", "b", "c"))), FALSE, 10L)
str(l)
class(l)
typeof(l)
```

</details>

<br>
<details><summary>**Example**: Investigating named lists</summary>

```{r}
l <- list(l1 = 1, l2 = c("apple", "orange"), l3 = list(1, 2, 3))
str(l)
class(l)
typeof(l)
```

</details>


#### Dataframes

What are **dataframes**?

- **Dataframes** are a special kind of **list** with the following characteristics:
  - Each element is a **vector** (i.e., _a column in the dataframe_)
  - The element should be named (i.e., _column name in the dataframe_)
  - Each of the vectors must be the same length (i.e., _same number of rows in the dataframe_)
  - The data type of each vector may be different
- Dataframes can be created using the function `data.frame()`
- The `class()` of  a dataframe is `data.frame`
- The `typeof()` a dataframe is `list`


<br>
<details><summary>**Example**: Investigating dataframe</summary>

```{r}
df <- data.frame(
  colA = c(1, 2, 3),
  colB = c("a", "b", "c"),
  colC = c(TRUE, FALSE, TRUE),
  stringsAsFactors = FALSE
)
df
str(df)
class(df)
typeof(df)
```

</details>

### Identifying object types

Functions for identifying object types (_returns `TRUE` or `FALSE`_):

- `is.logical()`: Is object of type `logical`?
- `is.integer()`: Is object of type `integer`?
- `is.double()`: Is object of type `double`?
- `is.numeric()`: Is object of type `numeric`?
- `is.character()`: Is object of type `character`?
- `is.atomic()`: Is object of type `atomic`?
- `is.list()`: Is object of type `list`?
- `is.vector()`: Is object of type `vector`?


Function | logical | int | dbl | chr | list
---------|---------|-----|-----|-----|-----
`is.logical()` | X | | | |
`is.integer()` |  |X | | |
`is.double()` |  | |X | |
`is.numeric()` |  |X |X | |
`is.character()` |  | | |X |
`is.atomic()` |X  |X |X |X |
`is.list()` |  | | | | X
`is.vector()` |X  |X |X |X |X

<br>
<details><summary>**Example**: Identifying object types</summary>

```{r}
v <- c(5, 6, 7)
is.logical(v)
is.integer(v)
is.double(v)
is.numeric(v)
is.character(v)
is.atomic(v)
is.list(v)
is.vector(v)
```

</details>


### Converting between classes

Functions for converting between classes:

- `as.logical()`: Convert to `logical`
- `as.numeric()`: Convert to `numeric`
- `as.integer()`: Convert to `integer`
- `as.character()`: Convert to `character`
- `as.list()`: Convert to `list`
- `as.data.frame()`: Convert to `data.frame`


<br>
<details><summary>**Example**: Using `as.logical()` to convert to `logical`</summary>

Character vector coerced to logical vector:

```{r}
# Only "TRUE"/"FALSE", "True"/"False", "T"/"F", "true"/"false" are able to be coerced to logical type
as.logical(c("TRUE", "FALSE", "True", "False", "true", "false", "T", "F", "t", "f", ""))
```

Numeric vector coerced to logical vector:

```{r}
# 0 is treated as FALSE, while all other numeric values are treated as TRUE
as.logical(c(0, 0.0, 1, -1, 20, 5.5))
```

</details>

<br>
<details><summary>**Example**: Using `as.numeric()` to convert to `numeric`</summary>

Logical vector coerced to numeric vector:

```{r}
# FALSE is mapped to 0 and TRUE is mapped to 1
as.numeric(c(FALSE, TRUE))
```

Character vector coerced to numeric vector:

```{r, warning = FALSE}
# Strings containing numeric values can be coerced to numeric (leading 0's are dropped) 
# All other characters become NA
as.numeric(c("0", "007", "2.5", "abc", "."))
```

</details>

<br>
<details><summary>**Example**: Using `as.integer()` to convert to `integer`</summary>

Logical vector coerced to integer vector:

```{r}
# FALSE is mapped to 0 and TRUE is mapped to 1
as.integer(c(FALSE, TRUE))
```

Character vector coerced to integer vector:

```{r, warning = FALSE}
# Strings containing numeric values can be coerced to integer (leading 0's are dropped, decimals are truncated) 
# All other characters become NA
as.integer(c("0", "007", "2.5", "abc", "."))
```

Numeric vector coerced to integer vector:

```{r, warning = FALSE}
# All decimal places are truncated
as.integer(c(0, 2.1, 10.5, 8.8, -1.8))
```

</details>

<br>
<details><summary>**Example**: Using `as.character()` to convert to `character`</summary>

Logical vector coerced to character vector:

```{r}
as.character(c(FALSE, TRUE))
```

Numeric vector coerced to character vector:

```{r, warning = FALSE}
as.character(c(-5, 0, 2.5))
```

Integer vector coerced to character vector:

```{r, warning = FALSE}
as.character(c(-2L, 0L, 10L))
```

</details>

<br>
<details><summary>**Example**: Using `as.list()` to convert to `list`</summary>

Atomic vectors coerced to list:

```{r}
# Logical vector
as.list(c(TRUE, FALSE))

# Character vector
as.list(c("a", "b", "c"))

# Numeric vector
as.list(1:3)
```

</details>

<br>
<details><summary>**Example**: Using `as.data.frame()` to convert to `data.frame`</summary>

Lists coerced to dataframe:

```{r}
# Create a list
l <- list(A = c("x", "y", "z"), B = c(1, 2, 3))
str(l)

# Convert to class `data.frame`
df <- as.data.frame(l, stringsAsFactors = F)
str(df)
```

</details>


## Subsetting elements

What is **subsetting**?

- Subsetting refers to isolating particular elements of an object 
- Subsetting operators can be used to select/exclude elements (e.g., variables, observations)
- There are three subsetting operators: `[]`, `[[]]`, `$` 
- These operators function differently based on vector types (e.g., atomic vectors, lists, dataframes)

<br>
For the examples in the next few subsections, we will be working with the following named atomic vector, named list, and dataframe:

- Create named atomic vector called `v` with 4 elements

    ```{r}
    v <- c(a = 10, b = 20, c = 30, d = 40)
    v
    ```

- Create named list called `l` with 4 elements

    ```{r}
    l <- list(a = TRUE, b = c("a", "b", "c"), c = list(1, 2), d = 10L)
    l
    ```

- Create dataframe called `df` with 4 columns and 3 rows

    ```{r}
    df <- data.frame(
      a = c(11, 21, 31),
      b = c(12, 22, 32),
      c = c(13, 23, 33),
      d = c(14, 24, 34)
    )
    df
    ```
    
### Subsetting using `[]`

The `[]` operator:

- Subsetting an object using `[]` returns an object of the same type
  - E.g., Using `[]` on an atomic vector returns an atomic vector, using `[]` on a list returns a list, etc.
- The returned object will contain the element(s) you selected
- Object attributes are retained when using `[]` (e.g., _name_)

Six ways to subset using `[]`:

1. Use positive integers to return elements at specified index positions
2. Use negative integers to exclude elements at specified index positions
3. Use logical vectors to return elements where corresponding logical is `TRUE`
4. Empty vector `[]` returns original object (useful for dataframes)
5. Zero vector `[0]` returns empty object (useful for testing data)
6. If object is named, use character vectors to return elements with matching names

<br>
<details><summary>**Example**: Using positive integers with `[]`</summary>

**Selecting a single element**: Specify the index of the element to subset

```{r}
# Select 1st element from numeric vector (note that names attribute is retained)
v[1]

# Subsetted object will be of type `numeric`
class(v[1])

# Select 1st element from list (note that names attribute is retained)
l[1]

# Subsetted object will be a `list` containing the element
class(l[1])
```

<br>
**Selecting multiple elements**: Specify the indices of the elements to subset using `c()`

```{r}
# Select 3rd and 1st elements from numeric vector
v[c(3,1)]

# Subsetted object will be of type `numeric`
class(v[c(3,1)])

# Select 1st element three times from list
l[c(1,1,1)]

# Subsetted object will be a `list` containing the elements
class(l[c(1,1,1)])
```

</details>

<br>
<details><summary>**Example**: Using negative integers with `[]`</summary>

**Excluding a single element**: Specify the index of the element to exclude

```{r}
# Exclude 1st element from numeric vector (note that names are retained)
v[-1]

# Subsetted object will be of type `numeric`
class(v[-1])
```

<br>
**Excluding multiple elements**: Specify the indices of the elements to exclude using `-c()`

```{r}
# Exclude 1st and 3rd elements from list
l[-c(1,3)]

# Subsetted object will be a `list` containing the remaining elements
class(l[-c(1,3)])
```

</details>

<br>
<details><summary>**Example**: Using logical vectors with `[]`</summary>

If the logical vector is the same length as the object, then each element in the object whose corresponding position in the logical vector is `TRUE` will be selected:

```{r}
# Select 2nd and 3rd elements from numeric vector
v[c(FALSE, TRUE, TRUE, FALSE)]

# Subsetted object will be of type `numeric`
class(v[c(FALSE, TRUE, TRUE, FALSE)])
```

<br>
If the logical vector is shorter than the object, then the elements in the logical vector will be recycled:

```{r}
# This is equivalent to `l[c(FALSE, TRUE, FALSE, TRUE)]`, thus retaining 2nd and 4th elements
l[c(FALSE, TRUE)]

# Subsetted object will be a `list` containing the elements
class(l[c(FALSE, TRUE)])
```

<br>
We can also write expressions that evaluates to either `TRUE` or `FALSE`:
```{r}
# This expression is recycled and evaluates to be equivalent to `l[c(FALSE, FALSE, TRUE, TRUE)]`
v[v > 20]
```

</details>

<br>
<details><summary>**Example**: Using empty vector `[]`</summary>

An empty vector `[]` just returns the original object:

```{r}
# Original atomic vector
v[]

# Original list
l[]

# Original dataframe
df[]
```

</details>

<br>
<details><summary>**Example**: Using zero vector `[0]`</summary>

A zero vector `[0]` just returns an empty object of the same type as the original object:

```{r}
# Empty named atomic vector
v[0]

# Empty named list
l[0]

# Empty dataframe
df[0]
```

</details>

<br>
<details><summary>**Example**: Using element names with `[]`</summary>

We can select a single element or multiple elements by their name(s):

```{r}
# Equivalent to v[2]
v["b"]

# Equivalent to l[c(1, 3)]
l[c("a", "c")]
```

</details>

### Subsetting using `[[]]`

The `[[]]` operator:

- We can only use `[[]]` to extract a single element rather than multiple elements
- Subsetting an object using `[[]]` returns the selected element itself, which might not be of the same type as the original object
  - E.g., Using `[[]]` to select an element from a list that is a numeric vector will return that numeric vector and not a list containing that numeric vector, like what `[]` would return
    - Let `x` be a list with 3 elements (_Think of it as a train with 3 cars_)
    [![](https://d33wubrfki0l68.cloudfront.net/1f648d451974f0ed313347b78ba653891cf59b21/8185b/diagrams/subsetting/train.png)](https://adv-r.hadley.nz/subsetting.html#subset-single)
    - `x[1]` will be a list containing the 1st element, which is a numeric vector (i.e., _train with the 1st car_)
    - `x[[1]]` will be the numeric vector itself (i.e., _the objects within the 1st car_)
    [![](https://d33wubrfki0l68.cloudfront.net/aea9600956ff6fbbc29d8bd49124cca46c5cb95c/28eaa/diagrams/subsetting/train-single.png)](https://adv-r.hadley.nz/subsetting.html#subset-single)
    - *Source: Subsetting from [R for Data Science](https://adv-r.hadley.nz/subsetting.html)*
- Object attributes are removed when using `[[]]`
  - E.g., Using `[[]]` on a named object returns just the selected element itself without the name attribute

<br>
Two ways to subset using `[[]]`:

1. Use a positive integer to return an element at the specified index position
2. If object is named, using a character to return an element with the specified name

<br>
<details><summary>**Example**: Using positive integer with `[[]]`</summary>

```{r}
# Select 1st element from numeric vector (note that names attribute is gone)
v[[1]]

# Subsetted element is `numeric`
class(v[[1]])

# Select 1st element from list (note that names attribute is gone)
l[[1]]

# Subsetted element is `logical`
class(l[[1]])
```

</details>

<br>
<details><summary>**Example**: Using element name with `[[]]`</summary>

```{r}
# Equivalent to v[[2]]
v[["b"]]

# Subsetted element is `numeric`
class(v[["b"]])

# Equivalent to l[[2]]
l[["b"]]

# Subsetted element is `character` vector
class(l[["b"]])
```

</details>


### Subsetting using `$`

The `$` operator:

- `obj_name$element_name` is shorthand for `obj_name[["element_name"]]`
- This operator only works on lists (including dataframes) and not on atomic vectors

<br>
<details><summary>**Example**: Subsetting with `$`</summary>

Subsetting a list with `$`:

```{r}
# Equivalent to l[["b"]]
l$b

# Subsetted element is `character` vector
class(l$b)
```

<br>
Since dataframes is just a special kind of named list, it would work the same way:

```{r}
# Equivalent to df[["d"]]
df$d
```

</details>

### Subsetting dataframes

Subsetting dataframes with `[]`, `[[]]`, and `$`:

- Subsetting dataframes works the same way as lists because dataframes are just a special kind of named list, where we can think of each element as a column
  - `df_name[<column(s)>]` returns a dataframe containing the selected column(s), with its attributes retained
  - `df_name[[<column>]]` or `df_name$<column>` returns the column itself, without any attributes
- In addition to the normal way of subsetting, we are also allowed to subset dataframes by cell(s)
  - `df_name[<row(s)>, <column(s)>]` returns the selected cell(s)
    - If a single cell is selected, or cells from the same column, then these would be returned as an object of the same type as that column (similar to how `[[]]` normally works)
    - Otherwise, the subsetted object would be a dataframe, as we'd normally expect when using `[]`
  - `df_name[[<row>, <column>]]` returns the selected cell

<br>
<details><summary>**Example**: Subsetting dataframe column(s) with `[]`</summary>

We can subset dataframe column(s) the same way we have subsetted atomic vector or list element(s):

```{r}
# Select 1st column from dataframe (note that names attribute is retained)
df[1]

# Subsetted object will be a `data.frame` containing the column
class(df[1])

# Exclude 1st and 3rd columns from dataframe (note that names attribute is retained)
df[-c(1,3)]

# Subsetted object will be a `data.frame` containing the remaining columns
class(df[-c(1,3)])
```

</details>

<br>
<details><summary>**Example**: Subsetting dataframe column with `[[]]` and `$`</summary>

We can select a single dataframe column the same way we have subsetted a single atomic vector or list element:

```{r}
# Select 1st column from dataframe by its index (note that names attribute is gone)
df[[1]]

# Subsetted column is `numeric` vector
class(df[[1]])

# Equivalently, we could've selected 1st column by its name
df[["a"]]

# Equivalently, we could've selected 1st column using `$`
df$a
```

</details>

<br>
<details><summary>**Example**: Subsetting dataframe cell(s) with `[]`</summary>

If we select a single cell by specifying its row and column, we will get back the element itself, not in a dataframe:

```{r}
# Selects cell in 1st row and 2nd col
df[1, 2]

# Subsetted cell is of type `numeric`
class(df[1, 2])

# Equivalently, we could select using column name instead of index
df[1, "b"]
```

<br>
Similarly, if we select cells from the same column, we will get back the elements themselves, not in a dataframe:

```{r}
# Selects cells from the 2nd col
df[c(1,3), 2]

# Subsetted cells is of type `numeric`
class(df[c(1,3), 2])

# Selects all cells from the 2nd col
df[, 2]

# Subsetted column is of type `numeric`
class(df[, 2])
```

<br>
However, if we select cells from the same row, or cells across multiple rows and columns, we will get back a dataframe that contains the selected cells:

```{r}
# Selects cells from the 2nd row
df[2, c("a", "c")]

# Subsetted cells are returned as a dataframe
class(df[2, c("a", "c")])

# Selects all cells from the 2nd row
df[2, ]

# Subsetted row is returned as a dataframe
class(df[2, ])

# Selects cells from multiple rows and columns
df[1:2, c("a", "c")]

# Subsetted cells are returned as a dataframe
class(df[1:2, c("a", "c")])
```

</details>

<br>
<details><summary>**Example**: Subsetting dataframe cell with `[[]]`</summary>

With `[[]]`, we are only allowed to select a single cell:

```{r}
# Selects cell in 1st row and 2nd col
df[[1, 2]]

# Subsetted cell is of type `numeric`
class(df[[1, 2]])

# This is equivalent to using `[]`
df[1, 2]
```

</details>

## Attributes [SKIP]

### Augmented vectors

What are **augmented vectors** and **attributes**?

- Atomic vectors can be thought of as "just the data", while **augmented vectors** are atomic vectors with additional attributes attached
- **Attributes** are additional "metadata" that can be attached to any object (e.g., vector or list)
  - E.g., __Value labels__: Character labels (e.g., "Charter School") attached to numeric values
  - E.g., __Object class__: Specifies how object is treated by object oriented programming language
- Recall that when we subset by `[]`, all the attributes are retained. When we subset by `[[]]`, we get back "just the data" without any of the attributes.

**Example**: Variables of a dataset

- A data frame is a list
- Each element in the list is a variable (i.e., column), which consists of:
    - Atomic vector ("just the data")
    - Variable _name_, which is an attribute we attach to the element/variable
    - Any other attributes we want to attach to element/variable

__Main takaway__:

- Augmented vectors are atomic vectors (just the data) with additional attributes attached
- Description of attributes from [Wickham and Grolemund](https://r4ds.had.co.nz/vectors.html#attributes):
  - "Any vector can contain arbitrary additional __metadata__ through its __attributes__"
  - "You can think of __attributes__ as named list of vectors that can be attached to any object"
- Functions to identify and modify attributes
  - `attributes()`: View all attributes of an object or set/change all attributes of an object
  - `attr()`: View individual attribute of an object or set/change an individual attribute of an object

### `attributes()` function

__The `attributes()` function__:

```{r, eval=FALSE}
?attributes

# SYNTAX
attributes(x)  # Get attributes
attributes(x) <- value  # Set attributes
```

- Function: Get or set all attributes of an object
- Arguments
  - `x`: The object whose attributes we want to view or modify
  - `value`: In the assignment form, the value we want to set all attributes to be

<br>
<details><summary>**Example**: Using `attributes()` to get attributes of object</summary>

Recall our dataframe `df` from the previous examples, which has multiple attributes:

```{r}
df

# View attributes of dataframe
attributes(df)
```

<br>
When we subset by `[]`, attributes are retained:

```{r}
# Subset 1st column using `[]`
df[1]

# Attributes are retained when we subset by `[]`
attributes(df[1])
```

<br>
When we subset by `[[]]`, attributes are removed and we are left with "just the data":

```{r}
# Subset 1st column using `[[]]`
df[[1]]

# Attributes are gone when we subset by `[[]]`
attributes(df[[1]])
```

</details>

<br>
<details><summary>**Example**: Using `attributes()` to set attributes of object</summary>

Recall our named atomic vector `v` from the previous examples, which has the _name_ attribute:

```{r}
v

# View attributes of atomic vector
attributes(v)
```

<br>
Remove all attributes from the vector:

```{r}
# Set all attributes to NULL
attributes(v) <- NULL

# The atomic vector is no longer named
v

# Confirm that the names attribute is no longer there
attributes(v)
```

</details>

### `attr()` function

__The `attr()` function__:

```{r, eval=FALSE}
?attr

# SYNTAX AND DEFAULT VALUES
attr(x, which, exact = FALSE)  # Get attribute
attr(x, which) <- value  # Set attribute
```

- Function: Get or set a specific attribute of an object
- Arguments
  - `x`: The object whose attribute we want to view or modify
  - `which`: A non-empty string specifying which attribute is to be accessed
  - `exact`: If set to `TRUE`, the attribute specified by `which` needs to be matched exactly
  - `value`: In the assignment form, the value we want to set the attribute to be

<br>
<details><summary>**Example**: Using `attr()` to get attribute of object</summary>

Recall our dataframe `df` from the previous examples, which has multiple attributes:

```{r}
df

# View attributes of dataframe
attributes(df)
```

<br>
We can use `attr()` to fetch individual attributes:

```{r}
# Get the names attribute
attr(df, "names")

# Note that we don't have to provide the full name of attribute for it to be recognized
attr(df, "nam")

# If we specify `exact = TRUE`, then we do have to provide exact attribute name
attr(df, "names", exact = TRUE)

# This no longer works
attr(df, "nam", exact = TRUE)
```

</details>

<br>
<details><summary>**Example**: Using `attr()` to set attribute of object</summary>

Recall the atomic vector `v` that we've removed all attributes from in the previous example:

```{r}
v

# View attributes of atomic vector
attributes(v)
```

<br>
We can add back the `names` attributes using `attr()`:

```{r}
# Add back names attribute
attr(v, "names") <- c("a", "b", "c", "d")

# View attributes
attributes(v)
```

<br>
We can also create any other attributes we want:

```{r}
# Create new attribute called `greeting`
attr(x = v, which = "greeting") <- "Hi!"

# View `greeting` attribute
attr(x = v, which = "greeting")

# View all attributes
attributes(v)
```

<br>
We can use `NULL` to remove attributes:

```{r}
# Remove `greeting` attribute
attr(x = v, which = "greeting") <- NULL

# Try viewing `greeting` attribute
attr(x = v, which = "greeting")

# View all attributes
attributes(v)
```

</details>

<br>
<details><summary>**Example**: Using `attr()` to set attribute of dataframe variable</summary>

Unlike atomic vectors, we can also set attributes of individual elements of lists (which include dataframes). Recall our dataframe `df`:

```{r}
df

# View attributes of dataframe
attributes(df)
```

<br>
We can also add attributes to an individual column (i.e., variable) of the dataframe using `[[]]` or `$`:

```{r}
# Equivalent to df[["a"]] - Remember this usually starts off as "just the data" with no attributes
attributes(df$a)

# Add an attribute
attr(df$a, "description") <- "A is for Apple"

# View attributes
attributes(df$a)
```

<br>
We can use `NULL` to remove attribute:

```{r}
# Remove `description` attribute
attr(df$a, "description") <- NULL

# Try viewing `description` attribute
attr(df$a, "description")

# View attributes
attributes(df$a)
```

</details>

## Names and values [EMPTY]

## Prerequisite concepts

Several functions and concepts are used frequently when creating loops and/or functions.

### Sequences

What are **sequences**?

- (Loose) definition: A **sequence** is a list of numbers in ascending or descending order
- Sequences can be created using the `:` operator or `seq()` function

**Example**: Creating sequences using `:`

```{r}
# Sequence from -5 to 5
-5:5

# Sequence from 5 to -5
5:-5
```

<br>
__The `seq()` function__:

```{r, eval = FALSE}
?seq

# SYNTAX AND DEFAULT VALUES
seq(from = 1, to = 1, by = ((to - from)/(length.out - 1)),
    length.out = NULL, along.with = NULL, ...)
```

- Function: Generate a sequence
- Arguments
  - `from`: The starting value of sequence
  - `to`: The end (or maximal) value of sequence
  - `by`: Increment of the sequence

**Example**: Creating sequences using `seq()`

```{r}
# Sequence from 10 to 15, by increment of 1 (default)
seq(10,15)

# Explicitly specify increment of 1 (equivalent to above)
seq(from=10, to=15, by=1)

# Sequence from 100 to 150, by increment of 10
seq(from=100, to=150, by=10)
```

### Length

__The `length()` function__:

```{r, eval = FALSE}
?length

# SYNTAX
length(x)
```

- Function: Returns the number of elements in the object
- Arguments:
  - `x`: The object to find the length of

<br>
**Example**: Using `length()` to find number of elements in `v`

```{r}
# View the atomic vector
v

# Use `length()` to find number of elements
length(v)
```

<br>
**Example**: Using `length()` to find number of elements in `df`

Remember that dataframes are just lists where each element is a column, so the number of elements in a dataframe is just the number of columns it has:

```{r}
# View the dataframe
df

# Use `length()` to find number of elements (i.e., columns)
length(df)
```

<br>
When we subset a dataframe using `[]` (i.e., _select column(s) from the dataframe_), the length of the subsetted object is the number of columns we selected:

```{r}
# Subset one column
df[1]

# Length is one
length(df[1])

# Subset three columns
df[1:3]

# Length is three
length(df[1:3])
```

<br>
When we subset a dataframe using `[[]]` (i.e., _isolate a specific column in the dataframe_), the length of the subsetted object is the number of rows in the dataframe:

```{r}
# Isolate a specific column
df[[2]]

# Length is number of elements in that column (i.e., number of rows in dataframe)
length(df[[2]])
```


### Sequences and length

When writing loops, it is very common to create a sequence from 1 to the length (i.e., number of elements) of an object.

<br>
**Example**: Generating a sequence from 1 to length of `v`

```{r}
# There are 4 elements in the atomic vector
v

# Use `:` to generate a sequence from 1 to 4
1:length(v)

# Use `seq()` to generate a sequence from 1 to 4
seq(1, length(v))
```

<br>
There is also a function `seq_along()` that makes it easier to generate a sequence from 1 to the length of an object.

<br>
__The `seq_along()` function__:

```{r, eval = FALSE}
?seq_along

# SYNTAX
seq_along(x)
```

- Function: Generates a sequence from 1 to the length of the input object
- Arguments
  - `x`: The object to generate the sequence for

<br>
**Example**: Generating a sequence from 1 to length of `df`

```{r}
# There are 4 elements (i.e., columns) in the dataframe
df

# Use `seq_along()` to generate a sequence from 1 to 4
seq_along(df)
```

### Directories and paths [SKIP]

<br>

#### Current working directory

When you run R code in an `.Rmd` file, the working directory is the directory that your `.Rmd` file is in:

```{r}
getwd()
```

<br>
When you run an `.R` script, the working directory is the directory indicated at the top of your console in RStudio:

![](../../assets/images/r_console.png)

- This is typically your home directory if you are not working from an RStudio project
- If you are working from an RStudio project, your working directory would be the project directory

<br>

#### Creating and deleting directories

<br>
__The `dir.create()` function__:

```{r, eval = FALSE}
?dir.create

# SYNTAX AND DEFAULT VALUES
dir.create(path, showWarnings = TRUE, recursive = FALSE, mode = "0777")
```

- Function: Creates new directories
- Arguments  
  - `path`: A character vector containing a single path name
  - `showWarnings`: Should the warnings on failure be shown?
    - If directory you want to create already exists, you will get a warning, but this won't cause the code to stop running
  - `recursive`: Should elements of the path other than the last be created?
    - That is, will `dir.create()` create the file path `new_directory/new_sub_directory` if neither `new_directory` nor `new_sub_directory` exist?

<br>
**Example**: Creating a new directory within current working directory

```{r}
# Check current working directory
getwd()

# Create new directory called `my_folder`
dir.create(path = "my_folder")

# Check that `my_folder` has been created
list.files()
```

<br>
__The `unlink()` function__:

```{r, eval = FALSE}
?unlink

# SYNTAX AND DEFAULT VALUES
unlink(x, recursive = FALSE, force = FALSE)
```

- Function: Deletes files or directories
- Arguments  
  - `x`: A character vector with the names of the files or directories to be deleted
  - `recursive`: Should directories be deleted recursively?
    - If recursive = `FALSE`, directories are not deleted, not even empty ones.
  - `force`: Should permissions be changed (if possible) to allow the file or directory to be removed?

<br>
**Example**: Deleting a directory within current working directory

```{r}
# Delete `my_folder` we just created
unlink(x = "my_folder", recursive = TRUE) 

# Check that `my_folder` has been deleted
list.files()
```

<br>

#### File paths

> We use the `file.path()` command because it is smart. Some computer operating systems use forward slashes, `/`, for their file paths; others use backslashes, `\`. Rather than try to guess or assume what operating system future users will use, we can use R's function, `file.path()`, to check the current operating system and build the paths correctly for us.

*Credit: [Organizing Lecture](https://edquant.github.io/edh7916/lessons/organizing.html) by Ben Skinner*

<br>
__The `file.path()` function__:

```{r, eval = FALSE}
?file.path

# SYNTAX AND DEFAULT VALUES
file.path(..., fsep = .Platform$file.sep)
```

- Pass in each section of the file path as a separate argument
  - Example: `file.path('.', 'lectures', 'week_1')` returns `'./lectures/week_1'`
- You can also save this file path object in a variable
  - Example: `lec_dir <- file.path('.', 'lectures', 'week_1')`


# Iteration

What is **iteration**?

- Iteration is the repetition of some process or operation
  - Example: Iteration can help with "repeating the same operation on different columns, or on different datasets" (From [R for Data Science](https://r4ds.had.co.nz/iteration.html))
- Looping is the most common way to iterate

## Loop basics

What are **loops**?

- __Loops__ execute some set of commands multiple times
- Each time the loop executes the set of commands is an __iteration__
- The below loop iterates 4 times

<br>
__Example__: Printing each element of the vector `c(1,2,3,4)` using a loop

```{r}
c(1,2,3,4)  # There are 4 elements in the vector

for(i in c(1,2,3,4)) {  # Iterate over each element of the vector
  print(i)  # Print out each element
}
```

<br>
When to write **loops**?

- Broadly, rationale for writing loop:
  - Do not duplicate code
  - Can make changes to code in one place rather than many
- When to write a loop:
  - Grolemund and Wickham say __don't copy and paste more than twice__
  - If you find yourself doing this, consider writing a loop or function
- Don't worry about knowing all the situations you should write a loop
  - Rather, you'll be creating analysis dataset or analyzing data and you will notice there is some task that you are repeating over and over
  - Then you'll think, "Oh, I should write a loop or function for this"


## Components of a loop

How to write a **loop**?

- We can build loops using the `for()` function
- The **loop sequence** goes inside the parentheses of `for()`
- The **loop body** goes inside the pair of curly brackets (`{}`) that follows `for()`

```{r, eval=FALSE}
for(i in c(1,2,3,4)) {  # Loop sequence
  print(i)  # Loop body
}
```

<br>
Components of a **loop**:

1. __Sequence__: Determines what to "loop over"
    - In the above example, the sequence is `i in c(1,2,3,4)`
    - This creates a temporary/local object named `i` (could name it anything)
    - Each iteration of the loop will assign a different value to `i`
    - `c(1,2,3,4)` is the set of values that will be assigned to `i` 
        - In the first iteration, the value of `i` is `1`
        - In the second iteration, the value of `i` is `2`, etc.
2. __Body__: What commands to execute for each iteration of the loop
    - In the above example, the body is `print(i)`
    - Each time through the loop (i.e., iteration), body prints the value of object `i`
    

### Ways to write loop sequence

You may see the loop sequence being written in slightly different ways. For example, these three loops all do the same thing:

- Looping over the vector `c(1,2,3)`

    ```{r}
    for(z in c(1,2,3)) {  # Loop sequence
      print(z)  # Loop body
    }
    ```

- Looping over the sequence `1:3` 

    ```{r}
    for(z in 1:3) {  # Loop sequence
      print(z)  # Loop body
    }
    ```

- Looping over the object `num_sequence`
    
    ```{r}
    num_sequence <- 1:3
    for(z in num_sequence) {  # Loop sequence
      print(z)  # Loop body
    }
    ```

### Printing values in loop body

When building a loop, it is useful to print out information to understand what the loop is doing.

For example, the two loops below are essentially the same, but the second approach is preferable because it more clearly prints out what object we are working with inside the loop:

- Using `print()` to print a single object `z`:

    ```{r}
    for(z in c(1,2,3)) {
      print(z)
    }
    ```

- Using `str_c()` and `writeLines()` to concatenate and print multiple items:

    ```{r}
    for(z in c(1,2,3)) {
      writeLines(str_c("object z=", z))
    }
    ```

### Student exercise


1. Create a numeric vector that contains the year of birth of your family members
    - Example: `birth_years <- c(1944,1950,1981,2016)`
2. Write a loop that calculates the current year minus birth year and prints this number for each member of your family
    - Within this loop, you will create a new variable that calculates current year minus birth year

<br>
<details><summary>**Solution**</summary>

```{r}
birth_years <- c(1944,1950,1981,2016)
birth_years

for(y in birth_years) {  # Loop sequence
  writeLines(str_c("object y=", y))  # Loop body
  z <- 2020 - y
  writeLines(str_c("value of ", y, " minus ", 2018, " is ", z))
}
```
</details>


## Ways to loop over a vector

There are 3 ways to loop over elements of an object:

1. [Looping over the elements](#looping-over-elements) (approach we have used so far)
2. [Looping over names of the elements](#looping-over-names)
3. [Looping over numeric indices associated with element position](#looping-over-indices) (approach recommended by Grolemnund and Wickham)

<br>
For the examples in the next few subsections, we will be working with the following named atomic vector and dataframe:

- Create named atomic vector called `vec`

    ```{r}
    vec <- c(a = 5, b = -10, c = 30)
    vec
    ```

- Create dataframe called `df` with randomly generated data, 3 columns (vars) and 4 rows (obs)

    ```{r}
    set.seed(12345) # so we all get the same variable values
    df <- tibble(a = rnorm(4), b = rnorm(4), c = rnorm(4))
    str(df)
    ```

### Looping over elements

**Syntax**: `for (i in object_name)`

- This approach iterates over each element in the object
- The value of `i` is equal to the element's _content_ (rather than its _name_ or _index position_)

<br>
**Example**: Looping over elements in `vec`
    
```{r}
vec  # View named atomic vector object

for (i in vec) {
  writeLines(str_c("value of object i=",i))
  writeLines(str_c("object i has: type=", typeof(i), "; length=", length(i), "; class=", class(i),
      "\n"))  # "\n" adds line break
}
```

<br>
**Example**: Looping over elements in `df`

```{r}
df  # View dataframe object

for (i in df) {
  writeLines(str_c("value of object i=",i))
  writeLines(str_c("object i has: type=", typeof(i), "; length=", length(i), "; class=", class(i),
      "\n"))  # "\n" adds line break
}
```

<br>
<details><summary>**Example**: Calculating column averages for `df` by looping over columns</summary>

The dataframe `df` is a list object, where each element is a vector (i.e., column):

```{r}
df  # View dataframe object

for (i in df) {
  writeLines(str_c("value of object i=", i))
  writeLines(str_c("mean value of object i=", mean(i, na.rm = TRUE), "\n"))
}
```
</details>

### Looping over names

**Syntax**: `for (i in names(object_name))`

- To use this approach, elements in the object must have name attributes
- This approach iterates over the names of each element in the object
- `names()` returns a vector of the object's element names
- The value of `i` is equal to the element's _name_ (rather than its _content_ or _index position_)
- But note that it is still possible to access the element's content inside the loop:
    - Access element contents using `object_name[i]`
        - Same object type as `object_name`; retains attributes (e.g., _name_)
    - Access element contents using `object_name[[i]]`
        - Removes level of hierarchy, thereby removing attributes
        - Approach recommended by Wickham because it isolates value of element

<br>
**Example**: Looping over elements in `vec`

```{r}
vec  # View named atomic vector object
names(vec)  # View names of atomic vector object

for (i in names(vec)) {
  writeLines(str_c("\nvalue of object i=", i, "; type=", typeof(i)))
  str(vec[i])  # Access element contents using []
  str(vec[[i]])  # Access element contents using [[]]
}
```

<br>
**Example**: Looping over elements in `df`

```{r}
df  # View dataframe object
names(df)  # View names of dataframe object (i.e., column names)

for (i in names(df)) {
  writeLines(str_c("\nvalue of object i=", i, "; type=", typeof(i)))
  str(df[i])  # Access element contents using []
  str(df[[i]])  # Access element contents using [[]]
}
```


<br>
<details><summary>**Example**: Calculating column averages for `df` by looping over column names</summary>

```{r}
str(df)  # View structure of dataframe object
```

<br>
Remember that we can use `[[]]` to access element contents by their name:

```{r}
for (i in names(df)) {
  writeLines(str_c("mean of element named", i, "=", mean(df[[i]], na.rm = TRUE)))
}
```

<br>
If we tried completing the task using `[]` to access the element contents, we would get an error because `mean()` only takes numeric or logical vectors as input, and `df[i]` returns a dataframe object:

```{r, eval=FALSE}
for (i in names(df)) {
  writeLines(str_c("mean of element named", i, "=", mean(df[i], na.rm = TRUE)))
  
  # print(class(df[i]))
}
```

</details>

### Looping over indices


**Syntax**: `for (i in 1:length(object_name))` OR `for (i in seq_along(object_name))`

- This approach iterates over the index positions of each element in the object
- There are two ways to create the loop sequence:
    - `length()` returns the number of elements in the input object, which we can use to create a sequence of index positions (i.e., `1:length(object_name)`)
    - `seq_along()` returns a sequence of numbers that represent the index positions for all elements in the input object (i.e., equivalent to `1:length(object_name)`)
- The value of `i` is equal to the element's _index position_ (rather than its _content_ or _name_)
- But note that it is still possible to access the element's content inside the loop:
    - Access element contents using `object_name[i]`
        - Same object type as `object_name`; retains attributes (e.g., _name_)
    - Access element contents using `object_name[[i]]`
        - Removes level of hierarchy, thereby removing attributes
        - Approach recommended by Wickham because it isolates value of element
- Similarly, we can access the element's name by its index using `names(object_name)[i]` or `names(object_name)[[i]]`
    - In this case, using `[[]]` and `[]` are equivalent because `names()` returns an unnamed vector, which does not have any attributes

<br>
**Example**: Looping over elements in `vec`

```{r}
vec  # View named atomic vector object
length(vec)  # View length of atomic vector object
1:length(vec)  # Create sequence from `1` to `length(vec)`

for (i in 1:length(vec)) {
  writeLines(str_c("\nvalue of object i=", i, "; type=", typeof(i)))
  str(vec[i])  # Access element contents using []
  str(vec[[i]])  # Access element contents using [[]]
}
```



<br>
**Example**: Looping over elements in `df`

```{r}
df  # View dataframe object
seq_along(df)  # Equivalent to `1:length(df)`

for (i in seq_along(df)) {
  writeLines(str_c("\nvalue of object i=", i, "; type=", typeof(i)))
  str(df[i])  # Access element contents using []
  str(df[[i]])  # Access element contents using [[]]
}
```

<br>
We could also access the element's name by its index:

```{r}
names(df)  # View names of dataframe object (i.e., column names)
names(df)[[2]]  # We can access any element in the names vector by its index

# Incorporate the above line into the loop
for (i in 1:length(df)) {
  writeLines(str_c("i=", i, "; name=", names(df)[[i]]))
}
```

<br>
<details><summary>**Example**: Calculating column averages for `df` by looping over column indices</summary>

Use `i in seq_along(df)` to loop over the column indices and `[[]]` to access column contents:

```{r}
str(df)  # View structure of dataframe object

for (i in seq_along(df)) {
  writeLines(str_c("mean of element at index position", i, "=", mean(df[[i]], na.rm = TRUE)))
}
```

</details>

### Summary

There are 3 ways to loop over elements of an object:

1. [Looping over the elements](#looping-over-elements)
2. [Looping over names of the elements](#looping-over-names)
3. [Looping over numeric indices associated with element position](#looping-over-indices) (approach recommended by Grolemnund and Wickham)
    - Grolemnund and Wickham recommends this approach (**#3**) because given an element's index position, we can also extract the element name (**#2**) and value (**#1**)


```{r}
for (i in seq_along(df)) {
  writeLines(str_c("i=", i))  # element's index position
  
  name <- names(df)[[i]]  # element's name (what we looped over in approach #2)
  writeLines(str_c("name=", name))
  
  value <- df[[i]]  # element's value (what we looped over in approach #1)
  writeLines(str_c("value=", value, "\n"))
}
```


## Modifying vs. creating object

Grolemund and Wickham differentiate between two types of tasks loops accomplish:

1. __Modifying an existing object__
    - Example: Looping through a set of variables in a dataframe to:
        - Modify these variables OR
        - Create new variables (within the existing dataframe object)
    - When writing loops in Stata/SAS/SPSS, we are usually modifying an existing object because these programs typically only have one object (a dataset) open at a time
2. __Creating a new object__
    - Example: Creating an object that has summary statistics for each variable, which can be the basis for a table or graph, etc.
    - The new object will often be a vector of results based on looping through elements of a dataframe
    - In R (as opposed to Stata/SAS/SPSS), creating a new object is very common because R can hold many objects at the same time


### Modifying an existing object

How to modify an existing object?

- Recall that we can directly access elements in an object (e.g., atomic vector, lists) using `[[]]`. We can use this same notation to _modify_ the object.
- Even though atomic vectors can also be modified with `[]`, Wickhams recommends using `[[]]` in all cases to make it clear we are working with a single element (from [R for Data Science](https://r4ds.had.co.nz/iteration.html#modifying-an-existing-object))

<br>
<details><summary>**Example**: Modifying an existing atomic vector</summary>

Recall our named atomic vector `vec` from the previous examples:

```{r}
vec
```

We can loop over the index positions and use `[[]]` to modify the object:

```{r}
for (i in seq_along(vec)) {
  vec[[i]] <- vec[[i]] * 2  # Double each element
}

vec
```

</details>

<br>
<details><summary>**Example**: Modifying an existing dataframe</summary>

Recall our dataframe `df` from the previous examples:

```{r}
df
```

We can loop over the index positions and use `[[]]` to modify the object:

```{r}
for (i in seq_along(df)) {
  df[[i]] <- df[[i]] * 2  # Double each element
}

df
```

</details>


### Creating a new object

So far our loops have two components: 

1. Sequence
1. Body

When we create a new object to store the results of a loop, our loops have three components:

1. Sequence
1. Body
1. **Output** (_This is the new object that will store the results created from your loop_)

<br>
Grolemund and Wickham recommend using `vector()` to create this new object __prior__ to writing the loop (rather than creating the new object within the loop):

> "Before you start loop...allocate sufficient space for the output. This is very important for efficiency: if you grow the for loop at each iteration using `c()` (for example), your for loop will be very slow."

<br>
__The `vector()` function__:

```{r, eval = FALSE}
?vector

# SYNTAX AND DEFAULT VALUES
vector(mode = "logical", length = 0)
```

- Function: Creates a new vector object of the given length and mode
- Arguments:
  - `mode`: Type of vector to create (e.g., `"logical"`, `"numeric"`, `"list"`)
  - `length`: Length of the vector

<br>
<details><summary>**Example**: Creating a new object to store dataframe column averages</summary>

Recall the previous example where we calculated the mean value of each column in dataframe `df`:

```{r}
str(df)

for (i in seq_along(df)) {
  writeLines(str_c("mean of element at index position", i, "=", mean(df[[i]], na.rm = TRUE)))
}
```

<br>
Let's create a new object to store these column averages. Specifically, we'll create a new numeric vector whose length is equal to the number of columns in `df`:

```{r}
output <- vector(mode = "numeric", length = length(df))
class(output)  # Specified by `mode` argument in `vector()`
length(output)  # Specified by `length` argument in `vector()`
```

<br>
We can loop over the index positions of `df` and use `[[]]` to modify `output`:

```{r}
for (i in seq_along(df)) {
  output[[i]] <- mean(df[[i]], na.rm = TRUE)  # Mean of df[[1]] assigned to output[[1]], etc.
}

output
```

</details>

## Summary

The general recipe for how to write a loop:

1. Complete the task for one instance outside a loop (this is akin to writing the __body__ of the loop)

2. Write the __sequence__ 

3. Which parts of the body need to change with each iteration

4. _If_ you are creating a new object to store output of the loop, create this outside of the loop

5. Construct the loop

<br>
<details><summary>**When to write a loop vs a function [SKIP]**</summary>

It's usually obvious when you are duplicating code, but unclear whether you should write a loop or whether you should write a function.

- Often, a repeated task can be completed with a loop or a function

In my experience, loops are better for repeated tasks when the individual tasks are __very__ similar to one another

- E.g., a loop that reads in datasets from individual years; each dataset you read in differs only by directory and name
- E.g., a loop that converts negative values to `NA` for a set of variables

Because functions can have many arguments, functions are better when the individual tasks differ substantially from one another 

- E.g., a function that runs regression and creates formatted results table
    - Function allows you to specify (as function arguments): dependent variable; independent variables; what model to run, etc.

__Note__:

- Can embed loops within functions; can call functions within loops
- But for now, just try to understand basics of functions and loops

</details>


## Practice: Download IPEDS 

Link to Ben Skinner's [downloadipeds.R](https://github.com/btskinner/downloadipeds/blob/master/downloadipeds.R)

```{r}
#load libraries
library(tidyverse)

#data directory path
data_dir <- file.path(".", "data")
data_dir

#Create a sub-folder for data inside your group repository
dir.create(path = "data", showWarnings = FALSE) # showWarnings = FALSE omits warnings if directory already exists

## -----------------------------------------------------------------------------
## Part I - Create objects for later use
## -----------------------------------------------------------------------------

url <- "https://nces.ed.gov/ipeds/datacenter/data/"
url

# suffix of file names
data_suffix <- ".zip" # suffix for csv data files [not stata data]
dict_suffix <- "_Dict.zip" # data dictionary
stata_do_suffix <- "_Stata.zip" # Stata do file w/ variable labels and value labels


# Read in string that has names of IPEDS files
ipeds <- readLines('./ipeds_file_list.txt')
#str(ipeds)
writeLines(ipeds[1:30])

# Use regular expressions to remove blank lines and lines that start with #

#Blank lines
str_view_all(string = ipeds[18:30], pattern ="^\\s*$") # blank lines
str_detect(string = ipeds[18:30], pattern ="^\\s*$") # blank lines

str_view_all(string = ipeds[18:30], pattern ="^[^(\\s*$)]") # NOT blank lines
str_detect(string = ipeds[18:30], pattern ="^[^(\\s*$)]") # NOT blank lines

length(str_subset(string = ipeds, pattern ="^[^(\\s*$)]"))
length(ipeds)

#remove blank lines
ipeds <- str_subset(string = ipeds, pattern ="^[^(\\s*$)]") # overwrite object to remove blanks
length(ipeds)

# lines that start with # (or do not start with #)

str_view_all(string = ipeds[1:30], pattern ="^#") # starts with "#"
str_detect(string = ipeds[1:30], pattern ="^#") # starts with "#"


str_view_all(string = ipeds[1:30], pattern ="^[^#]") # starts with anything but #
str_detect(string = ipeds[1:30], pattern ="^[^#]") # does not start with "#"

str_subset(string = ipeds, pattern ="^[^#]") # does not start with "#"
length(str_subset(string = ipeds, pattern ="^[^#]")) # does not start with "#"

#Remove lines that start with a "#"
ipeds <- str_subset(string = ipeds, pattern ="^[^#]") # does not start with "#"

ipeds[1:50]

# Create new character vector "hd" that contains names of all "HD" files
str_subset(string = ipeds, pattern = "^HD")
hd <- str_subset(string = ipeds, pattern = "^HD")

hd
hd[2]
hd[1:5]

length(hd)
seq(from = 1, to = length(hd))

## -----------------------------------------------------------------------------
## Part 2 - Creating loops
## -----------------------------------------------------------------------------

## -----------------------------------------------------------------------------
## LOOP 1: Create loop that prints URL for each dataset
## -----------------------------------------------------------------------------

# First, just work on creating loop without body and showing the value of object i and hd[i]
for (i in 1:length(hd)) {
  
  writeLines(str_c(i))
  #writeLines(str_c("object i=",i, "; hd[i]=",hd[i], sep = ""))
  #writeLines(str_c("i=",i, "; hd[",i,"]=",hd[i], sep = ""))
}

```


## Practice: IPEDS data & rvest package

```{r, message=FALSE}
## -----------------------------------------------------------------------------
## MODIFY HD 2018 DATASET
## -----------------------------------------------------------------------------
#Read in HD2018 data
hd2018 <- read_csv(file = file.path(data_dir,"hd2018.csv"))
#glimpse(hd2018)

#change column names to lowercase
names(hd2018) <- hd2018 %>% 
  names() %>%
  str_to_lower()
  
# Keep only subset of variables (including latitude and longitude, univerisity url, unitid, ) 
# and keep relatively small subset of institutions (e.g., a few UCs)

hd2018_uc <- hd2018 %>%
  dplyr::select(unitid, instnm, addr, stabbr, city, zip, latitude, longitud, webaddr) %>%
  filter(stabbr=="CA" & unitid %in% c(110644, 110662, 110671))
  
#typeof(hd2018_uc$webaddr)

# Create a character vector from the webaddr field and use that to create loop 
web <- hd2018_uc$webaddr

library(rvest) #load rvest package

web <- str_c("https://", web) #add https:// to web address

#str_extract(string = web, pattern = "\\.(w\\+)\\.")

#for loop to create xml_document/xml_node object
for(i in seq_along(web)) {
  
  url <- web[i] #grab url for each iteration
  
  name <- str_match(string = web[i], pattern = 'https://.+\\.([\\w]+)\\..+') #grab uni. name
  name <- name[,2] #get uni name on website
  
  html <- read_html(url) #use rvest function read_html to create xml_document/xml_node object
  
  assign(name, html) #assign name of uni. to object
  
  writeLines(str_c("web name: ", name, " url: ", url, sep = ""))
}

ucla_sm <- ucla %>%
  html_nodes('#social-media') #search for social-media ID

ucla_sm <- as.character(ucla_sm) #change to character


# Use `writeLines()` and `head()` to preview the first few rows of the data
writeLines(head(ucla_sm))

ucla_sm <- str_match(string = ucla_sm, pattern = '<a href="(http://twitter.+)"\\sclass.+</a>') #grab twitter url



ucr_sm <- UCR %>%
  html_nodes('.social-link') #search for social-link class

ucr_sm <- as.character(ucr_sm) #change to character

# Use `writeLines()` and `head()` to preview the first few rows of the data
writeLines(head(ucr_sm))

ucr_sm <- str_match(string = ucr_sm, pattern = '<a href="(https://twitter.+)"\\starget.+</a>') #grab twitter url



ucd_sm <- ucdavis %>%
  html_nodes('ul.pack') 

ucd_sm <- as.character(ucd_sm)

# Use `writeLines()` and `head()` to preview the first few rows of the data
writeLines(head(ucd_sm))

ucd_sm <- str_match(string = ucd_sm, pattern = '<a class=".+ href="(https://twitter.+)">.+</a>')



twitter_ucla <- ucla_sm[,2] #grab twitter urls
twitter_ucd <- ucd_sm[,2]
twitter_ucr <- ucr_sm[,2]

vec <- as_vector(c(twitter_ucd, twitter_ucla, twitter_ucr)) #create a vector of urls

hd2018_t <- bind_cols(hd2018_uc, data.frame(twitter = vec)) #add column to df

hd2018_t %>%
  select(instnm, webaddr, twitter)

```

# Conditional execution

## `if` statement conditions

What are **`if` statement conditions**?

- `if` statements allow you to conditionally execute certain blocks of code depending on whether some condition is satisfied
- The condition goes inside of the parentheses in `if()` and the block of code to execute goes between the curly brackets (`{}`)
- The condition must evaluate to either `TRUE` or `FALSE` (i.e., be of type `logical`)
- The condition must have length of `1`

```{r, eval=FALSE}
if (condition) {
  # code executed when condition is TRUE
}
```

<br>
The block of code is executed if the condition evaluates to `TRUE`:

```{r}
if (TRUE) {
  writeLines("This block is executed.")
}
```

The block of code is not executed if condition evaluates to `FALSE`:

```{r}
if (FALSE) {
  writeLines("This block is not executed.")
}
```

<br>
**Example**: Condition that evaluates to `TRUE`

Remember that any statement that has a length of `1` and can evaluate to either `TRUE` or `FALSE` can be used as the condition:

```{r}
# This statement evaluates to `TRUE`
2 + 2 == 4

# It is of type `logical`
typeof(2 + 2 == 4)

# It has length of `1`
length(2 + 2 == 4)

# We can use it as the if statement condition
if (2 + 2 == 4) {
  writeLines("This block is executed because `2 + 2 == 4` evaluates to `TRUE`.")
}
```

<br>
**Example**: Condition that evaluates to `FALSE`

Recall that some functions return a `logical`, so you might also see a function call being used as the condition:

```{r}
# This function call returns `FALSE` because there is no digit in the string "Fourth of July"
str_detect(string = "Fourth of July", pattern = "\\d")

# It is of type `logical`
typeof(str_detect(string = "Fourth of July", pattern = "\\d"))

# It has length of `1`
length(str_detect(string = "Fourth of July", pattern = "\\d"))

# We can use it as the if statement condition
if (str_detect(string = "Fourth of July", pattern = "\\d")) {
  writeLines("This block is not executed because the condition evaluates to `FALSE`.")
}
```

### `||` and `&&`

How to combine **multiple logical expressions** in a condition?

- Use `||` (or) and `&&` (and) to combine multiple logical expressions
- "Never use `|` or `&` in an if statement: these are _vectorised_ operations that apply to multiple values (that's why you use them in `filter()`)" (From [R for Data Science](https://r4ds.had.co.nz/functions.html#conditional-execution))
    - Vectorised operations mean they apply to each respective elements between the vectors:
        ```{r}
        c(TRUE, TRUE, FALSE) | c(TRUE, FALSE, FALSE)
        ```
    - Whereas `||` and `&&` will only look at the first element of each vector:
        ```{r}
        c(TRUE, TRUE, FALSE) || c(TRUE, FALSE, FALSE)
        ```

<br>
When using `||` (or), the block of code is executed if any of the conditions evaluates to `TRUE`:

```{r, eval=FALSE}
if (condition1 || condition2 || condition3) {
  # code executed when any of the conditions is TRUE
}
```

When using `&&` (and), the block of code is executed if all of the conditions evaluate to `TRUE`:

```{r, eval=FALSE}
if (condition1 && condition2 && condition3) {
  # code executed when all of the conditions are TRUE
}
```

<br>
<details><summary>**Example**: Using multiple logical expressions in a condition</summary>

```{r}

```

</details>

## `else` statements

What are **`else` statements**?

- After the `if` block, you can include an `else` block that will be executed if the `if` block did not execute
- In other words, the `else` block is executed if the `if` statement's condition is not met

```{r, eval=FALSE}
if (condition) {
  # code executed when condition is TRUE
} else {
  # code executed when condition is FALSE
}
```

<br>
<details><summary>**Example**: Using if-else statement</summary>

Let's take a look at using if-else statement to print whether a student is on academic probation because their GPA is under 2.0:

```{r}
# Student has GPA under 2.0 and is on academic probation
gpa <- 1.5
if (gpa < 2) {
  writeLines(str_c("Your GPA is ", gpa, " and you are on academic probation."))
} else {
  writeLines(str_c("Your GPA is ", gpa, " and you are NOT on academic probation."))
}

# Student has GPA over 2.0 and is NOT on academic probation
gpa <- 3.5
if (gpa < 2) {
  writeLines(str_c("Your GPA is ", gpa, " and you are on academic probation."))
} else {
  writeLines(str_c("Your GPA is ", gpa, " and you are NOT on academic probation."))
}
```

<br>
Recall that the condition evaluates to either `TRUE` or `FALSE`:

```{r}
# When student has 1.5 GPA, the condition evaluates to `TRUE`
gpa <- 1.5
gpa < 2

# When student has 3.5 GPA, the condition evaluates to `FALSE`
gpa <- 3.5
gpa < 2
```

<br>
The condition is of type `logical` and has a length of `1`:

```{r}
# Condition has type `logical`
typeof(gpa < 2)

# Condition has length of 1
length(gpa < 2)
```

</details>

<br>
<details><summary>**Example**: Using if-else statement with loop</summary>

Using the `diamonds` dataset from `ggplot2`, let's loop through the `price` of 5 of the diamonds and use an if-else statement to print whether each is affordable (under \$500) or pricey (\$500 and up):

```{r}
for (i in unique(diamonds$price)[21:25]) {
  if (i < 500) {
    writeLines(str_c("This diamond costs $", i, " and is affordable."))
  } else {
    writeLines(str_c("This diamond costs $", i, " and is pricey..."))
  }
}
```

</details>

## `else if` statements

What are **`else if` statements**?

- Between the `if` and `else` blocks, you can include additional block(s) using `else if` that gets executed if its condition is met and none of the previous blocks got executed
- In other words, only 1 block will ever execute in an `if`/`else if`/`else` chain

```{r, eval=FALSE}
if (condition) {
  # run this code if condition TRUE
} else if (condition) {
  # run this code if previous condition FALSE and this condition TRUE
} else if (condition) {
  # run this code if both previous conditions FALSE and this condition TRUE
} else {
  # run this code if all previous conditions FALSE
}
```

<br>
<details><summary>**Example**: Using `else if` statement</summary>

Using the `diamonds` dataset from `ggplot2`, let's loop through the `price` of 5 of the diamonds and print whether each is affordable (under \$500), pricey (between \$500 and \$1000), or too expensive (\$1000 and up):

```{r}
for (i in unique(diamonds$price)[23:27]) {
  if (i < 500) {
    writeLines(str_c("This diamond costs $", i, " and is affordable."))
  } else if (i >= 500 && i < 1000) {
    writeLines(str_c("This diamond costs $", i, " and is pricey..."))
  } else {
    writeLines(str_c("This diamond costs $", i, " and is too expensive!"))
  }
}
```

<br>
Remember that each subsequent `else if` statement will only be considered if all previous blocks did not run (i.e., their conditions were not met). This means we can simplify `i >= 500 && i < 1000` to `i < 1000` in the `else if` condition:

```{r}
for (i in unique(diamonds$price)[23:27]) {
  if (i < 500) {
    writeLines(str_c("This diamond costs $", i, " and is affordable."))
  } else if (i < 1000) {
    writeLines(str_c("This diamond costs $", i, " and is pricey..."))
  } else {
    writeLines(str_c("This diamond costs $", i, " and is too expensive!"))
  }
}
```

</details>

# Functions

## Function basics

What are **functions** and why use them?

- **Functions** are pre-written bits of code that accomplish some task
  - E.g., `str_c()` for concatenating strings, `make_date()` for creating a `Date` object
- We can call functions whenever we want to use them, again and again
- Since functions are _reusable_ pieces of code, they are very useful for helping us avoid repetition
- "You should consider writing a function whenever you've copied and pasted a block of code more than twice" (From [R for Data Science](https://r4ds.had.co.nz/functions.html#when-should-you-write-a-function))

<br>
How to write a **function**?

- We can define a function using `function()` and give it a **name** using the assignment operator `<-`
- Any **arguments** (i.e., inputs) the function takes should go inside the parentheses of `function()`
- The **body** of the function goes inside the pair of curly brackets (`{}`) that follows `function()`

```{r, eval=FALSE}
function_name <- function(arg1, arg2, arg3) {
  # function body
}
```

<br>
**Example**: Writing a function that prints a greeting

```{r}
# Define function called `print_hello()`
print_hello <- function() {  # This function takes no arguments
  "Hello!"                   # The body of the function simply prints "Hello!"
}

# Call function
print_hello()
```

<br>
Let's modify the `print_hello()` function to take the name of who we want to greet as an argument:

```{r}
# Define function
print_hello <- function(x) {  # The argument goes between the parentheses
  str_c("Hello ", x, "!")     # Use `str_c()` to concatenate the name of who we want to greet
}

# Call function
print_hello("World")
```

</details>

<br>
<details><summary>**Example**: Writing a function</summary>

```{r}
```

</details>

## Function arguments

### Default values

What are **default values** for arguments?

- The **default value** for an argument is the value that will be used if the argument was not supplied during the function call
- When writing the function, you can specify the **default value** for an argument using `name=value`

Recall the `print_hello()` function. Let's modify the function to make `x` have a default value:

```{r}
# Define function
print_hello <- function(x="there") {  # The default value for `x` is "there"
  str_c("Hello ", x, "!")
}

# Call function without passing in name (it will use default value)
print_hello()

# Call function and pass in name (it will override default value)
print_hello("World")
```


### Dot-dot-dot (`...`)

What is **dot-dot-dot (`...`)**?

- Dot-dot-dot (`...`) allows the function to take an arbitrary number of arguments
  - E.g., `str_c(..., sep = "", collapse = NULL)`
  - As seen, `str_c()` allows us to pass in an arbitrary number of character vectors to concatenate together
- "`...` (pronounced dot-dot-dot) [...] captures any number of arguments that aren’t otherwise matched." (From [R for Data Science](https://r4ds.had.co.nz/functions.html#dot-dot-dot))
- When we write our own function with the special argument `...`, we can pass those inputs into another function that takes `...` (e.g., `str_c()`)

Recall the `print_hello()` function. Let's modify the function to make it take an arbitrary number of names to greet:

```{r}
# Define function
print_hello <- function(...) {  # The function accepts an arbitrary number of inputs
  str_c("Hello ", str_c(..., sep = ", "), "!")  # Pass the `...` to `str_c()`
}

# Call function
print_hello("Dasher", "Dancer", "Prancer", "Vixen")
print_hello("Rudolf")
```

## Return values

### Implicit returns

What are **return values**?

- Just like how it can take inputs (i.e., arguments), functions can also return values as output
- The last statement that the function evaluates will be automatically (i.e., implicitly) returned
- If we want, we can store returned values in a variable for future use

Recall the `print_hello()` function:

```{r}
# Define function
print_hello <- function() {
  "Hello!"  # The last statement in the function is returned
}

# Call function
h <- print_hello()  # We can show that `print_hello()` returns a value by storing it in `h`
h                   # `h` stores the value "Hello!"
```

### Explicit returns

How can we **explicitly return values** from the function?

- We can use `return()` to explicitly return a value from our function
- This is commonly used when we want to return from the function early (e.g., inside an `if` block)
- There can be multiple `return()` in a function
- Returning from a function means exiting the function, so no other code below the point of return would be run

Recall the `print_hello()` function:

```{r}
# Define function
print_hello <- function() {
  return("Hello!")   # Explicitly return "Hello!"
  print("Goodbye!")  # Since this is after `return()`, it never gets run
}

# Call function
h <- print_hello()  # `print_hello()` returns "Hello!"
h
```


<br>
<details><summary>**Example**: Writing a function with multiple returns</summary>

Recall the previous example where we assess the prices of diamonds using the `diamonds` dataset from `ggplot2`. Let's move the `if`/`else if`/`else` blocks inside of a function, then call the function from inside the loop.

As seen below, the last statement that the function evaluates (i.e., whichever `if`/`else if`/`else` block is run) will be implicitly returned:

```{r}
assess_price <- function(price) {
  if (price < 500) {
    str_c("This diamond costs $", price, " and is affordable.")
  } else if (price < 1000) {
    str_c("This diamond costs $", price, " and is pricey...")
  } else {
    str_c("This diamond costs $", price, " and is too expensive!")
  }
}

for (i in unique(diamonds$price)[23:27]) {
  writeLines(assess_price(i))
}
```

<br>
But if we were to have another line after the conditional part, then that would be implicitly returned instead, since it is now the last statement in the function:

```{r}
assess_price <- function(price) {
  if (price < 500) {
    str_c("This diamond costs $", price, " and is affordable.")
  } else if (price < 1000) {
    str_c("This diamond costs $", price, " and is pricey...")
  } else {
    str_c("This diamond costs $", price, " and is too expensive!")
  }
  
  "I can't afford that."  # This is now the last statement in the function that will be returned
}

for (i in unique(diamonds$price)[23:27]) {
  writeLines(assess_price(i))
}
```

<br>
We can use `return()` to explicitly return early from the function:

```{r}
assess_price <- function(price) {
  if (price < 500) {
    return(str_c("This diamond costs $", price, " and is affordable."))  # Return early
  } else if (price < 1000) {
    return(str_c("This diamond costs $", price, " and is pricey..."))  # Return early
  } else {
    writeLines(str_c("This diamond costs $", price, " and is too expensive!"))
  }
  
  "I can't afford that."
}

for (i in unique(diamonds$price)[23:27]) {
  writeLines(assess_price(i))
}
```

</details>
